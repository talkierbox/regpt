# Disclaimer: This utility was entirely generated by Claude. This is the only part of the repo that is written with AI assistance.

"""
Experiment Logger & I/O Wrapper
================================
A flexible logging utility for ML experiments with easy data export.

Usage:
    from utils.logger import ExperimentLogger
    
    logger = ExperimentLogger("my_experiment")
    logger.log("Training started", level="info")
    logger.log_metrics({"loss": 0.5, "accuracy": 0.95})
    logger.export_json({"config": {...}}, "config.json")
    
    # Charts/Graphs (requires matplotlib)
    logger.plot_line(epochs, losses, "loss_curve", title="Training Loss")
    logger.plot_metrics()  # Auto-plot all tracked metrics
    logger.plot_bar(labels, values, "comparison")
    logger.plot_scatter(x, y, "correlation")
"""

import json
import csv
import pickle
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Union, Tuple, Callable
from functools import wraps
from contextlib import contextmanager

# Optional matplotlib import (lazy loaded)
_plt = None
_mpl = None

def _get_plt():
    """Lazy load matplotlib.pyplot."""
    global _plt
    if _plt is None:
        try:
            import matplotlib.pyplot as plt
            _plt = plt
            # Use non-interactive backend for saving
            import matplotlib
            matplotlib.use('Agg')
        except ImportError:
            raise ImportError(
                "matplotlib is required for plotting. "
                "Install it with: pip install matplotlib"
            )
    return _plt

# ANSI color codes for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'

LEVEL_COLORS = {
    "debug": Colors.DIM,
    "info": Colors.CYAN,
    "success": Colors.GREEN,
    "warning": Colors.YELLOW,
    "error": Colors.RED,
    "critical": Colors.RED + Colors.BOLD,
}

LEVEL_ICONS = {
    "debug": "üîç",
    "info": "‚ÑπÔ∏è ",
    "success": "‚úÖ",
    "warning": "‚ö†Ô∏è ",
    "error": "‚ùå",
    "critical": "üî•",
}


class ExperimentLogger:
    """
    A comprehensive experiment logger with I/O utilities.
    
    Handles:
    - Console logging with colors
    - File logging
    - Metrics tracking over time
    - Data export (JSON, CSV, pickle, text)
    - Chart/graph export (PNG via matplotlib)
    - Experiment organization with timestamps
    """
    
    # Class-level logs root directory
    LOGS_ROOT = Path(__file__).parent.parent.parent / "logs"
    
    def __init__(
        self,
        experiment_name: str,
        create_subfolder: bool = True,
        console_output: bool = True,
        file_output: bool = True,
        timestamp_format: str = "%Y%m%d_%H%M%S",
    ):
        """
        Initialize an experiment logger.
        
        Args:
            experiment_name: Name of the experiment (used for folder naming)
            create_subfolder: Whether to create a timestamped subfolder
            console_output: Whether to print logs to console
            file_output: Whether to write logs to file
            timestamp_format: Format for timestamps in folder names
        """
        self.experiment_name = experiment_name
        self.console_output = console_output
        self.file_output = file_output
        self.timestamp_format = timestamp_format
        self.start_time = datetime.now()
        
        # Create experiment directory
        if create_subfolder:
            timestamp = self.start_time.strftime(timestamp_format)
            self.experiment_dir = self.LOGS_ROOT / f"{experiment_name}_{timestamp}"
        else:
            self.experiment_dir = self.LOGS_ROOT / experiment_name
            
        self.experiment_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize log file
        self.log_file = self.experiment_dir / "experiment.log"
        
        # Metrics storage
        self._metrics_history: List[Dict[str, Any]] = []
        self._step = 0
        
        # Log initialization
        self.log(f"Experiment '{experiment_name}' initialized", level="success")
        self.log(f"Logs directory: {self.experiment_dir}", level="info")
    
    # =========================================================================
    # LOGGING METHODS
    # =========================================================================
    
    def log(
        self,
        message: str,
        level: str = "info",
        timestamp: bool = True,
    ) -> None:
        """
        Log a message to console and/or file.
        
        Args:
            message: The message to log
            level: Log level (debug, info, success, warning, error, critical)
            timestamp: Whether to include timestamp
        """
        now = datetime.now()
        ts_str = now.strftime("%H:%M:%S") if timestamp else ""
        
        # Console output with colors
        if self.console_output:
            color = LEVEL_COLORS.get(level, "")
            icon = LEVEL_ICONS.get(level, "")
            level_str = f"[{level.upper():^8}]"
            
            console_line = f"{Colors.DIM}{ts_str}{Colors.RESET} {color}{level_str}{Colors.RESET} {icon} {message}"
            print(console_line)
        
        # File output (plain text)
        if self.file_output:
            file_line = f"{ts_str} [{level.upper():^8}] {message}\n"
            with open(self.log_file, "a") as f:
                f.write(file_line)
    
    def debug(self, message: str) -> None:
        """Log a debug message."""
        self.log(message, level="debug")
    
    def info(self, message: str) -> None:
        """Log an info message."""
        self.log(message, level="info")
    
    def success(self, message: str) -> None:
        """Log a success message."""
        self.log(message, level="success")
    
    def warning(self, message: str) -> None:
        """Log a warning message."""
        self.log(message, level="warning")
    
    def error(self, message: str) -> None:
        """Log an error message."""
        self.log(message, level="error")
    
    def critical(self, message: str) -> None:
        """Log a critical message."""
        self.log(message, level="critical")
    
    def separator(self, char: str = "‚îÄ", length: int = 60) -> None:
        """Print a visual separator line."""
        line = char * length
        if self.console_output:
            print(f"{Colors.DIM}{line}{Colors.RESET}")
        if self.file_output:
            with open(self.log_file, "a") as f:
                f.write(f"{line}\n")
    
    def header(self, title: str, char: str = "‚ïê") -> None:
        """Print a styled header."""
        border = char * (len(title) + 4)
        if self.console_output:
            print(f"\n{Colors.BOLD}{Colors.CYAN}{border}")
            print(f"{char} {title} {char}")
            print(f"{border}{Colors.RESET}\n")
        if self.file_output:
            with open(self.log_file, "a") as f:
                f.write(f"\n{border}\n{char} {title} {char}\n{border}\n\n")
    
    # =========================================================================
    # METRICS TRACKING
    # =========================================================================
    
    def log_metrics(
        self,
        metrics: Dict[str, Union[int, float]],
        step: Optional[int] = None,
        prefix: str = "",
    ) -> None:
        """
        Log metrics for tracking over time.
        
        Args:
            metrics: Dictionary of metric name -> value
            step: Step number (auto-increments if not provided)
            prefix: Optional prefix for metric names
        """
        if step is None:
            step = self._step
            self._step += 1
        
        # Apply prefix
        if prefix:
            metrics = {f"{prefix}/{k}": v for k, v in metrics.items()}
        
        # Store with metadata
        entry = {
            "step": step,
            "timestamp": datetime.now().isoformat(),
            **metrics,
        }
        self._metrics_history.append(entry)
        
        # Log to console
        metrics_str = " | ".join(f"{k}: {v:.4f}" if isinstance(v, float) else f"{k}: {v}" 
                                  for k, v in metrics.items())
        self.log(f"[Step {step}] {metrics_str}", level="info")
    
    def get_metrics_history(self) -> List[Dict[str, Any]]:
        """Return the full metrics history."""
        return self._metrics_history.copy()
    
    def get_best_metric(self, metric_name: str, mode: str = "min") -> Dict[str, Any]:
        """
        Get the best value for a specific metric.
        
        Args:
            metric_name: Name of the metric to find
            mode: 'min' or 'max'
        
        Returns:
            Dictionary with the entry containing the best metric value
        """
        relevant = [e for e in self._metrics_history if metric_name in e]
        if not relevant:
            return {}
        
        if mode == "min":
            return min(relevant, key=lambda x: x[metric_name])
        else:
            return max(relevant, key=lambda x: x[metric_name])
    
    # =========================================================================
    # DATA EXPORT METHODS
    # =========================================================================
    
    def export_json(
        self,
        data: Any,
        filename: str,
        subfolder: Optional[str] = None,
        indent: int = 2,
    ) -> Path:
        """
        Export data to a JSON file.
        
        Args:
            data: Data to export (must be JSON serializable)
            filename: Output filename (with or without .json extension)
            subfolder: Optional subfolder within experiment directory
            indent: JSON indentation level
            
        Returns:
            Path to the created file
        """
        if not filename.endswith(".json"):
            filename += ".json"
        
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "w") as f:
            json.dump(data, f, indent=indent, default=str)
        
        self.log(f"Exported JSON: {filepath.name}", level="success")
        return filepath
    
    def export_csv(
        self,
        data: Union[List[Dict], List[List]],
        filename: str,
        subfolder: Optional[str] = None,
        headers: Optional[List[str]] = None,
    ) -> Path:
        """
        Export data to a CSV file.
        
        Args:
            data: List of dicts or list of lists
            filename: Output filename (with or without .csv extension)
            subfolder: Optional subfolder within experiment directory
            headers: Column headers (auto-detected for list of dicts)
            
        Returns:
            Path to the created file
        """
        if not filename.endswith(".csv"):
            filename += ".csv"
        
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "w", newline="") as f:
            if data and isinstance(data[0], dict):
                # List of dictionaries
                headers = headers or list(data[0].keys())
                writer = csv.DictWriter(f, fieldnames=headers)
                writer.writeheader()
                writer.writerows(data)
            else:
                # List of lists
                writer = csv.writer(f)
                if headers:
                    writer.writerow(headers)
                writer.writerows(data)
        
        self.log(f"Exported CSV: {filepath.name} ({len(data)} rows)", level="success")
        return filepath
    
    def export_text(
        self,
        content: str,
        filename: str,
        subfolder: Optional[str] = None,
    ) -> Path:
        """
        Export text content to a file.
        
        Args:
            content: Text content to write
            filename: Output filename
            subfolder: Optional subfolder within experiment directory
            
        Returns:
            Path to the created file
        """
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "w") as f:
            f.write(content)
        
        self.log(f"Exported text: {filepath.name}", level="success")
        return filepath
    
    def export_pickle(
        self,
        data: Any,
        filename: str,
        subfolder: Optional[str] = None,
    ) -> Path:
        """
        Export data to a pickle file.
        
        Args:
            data: Any Python object
            filename: Output filename (with or without .pkl extension)
            subfolder: Optional subfolder within experiment directory
            
        Returns:
            Path to the created file
        """
        if not filename.endswith(".pkl"):
            filename += ".pkl"
        
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "wb") as f:
            pickle.dump(data, f)
        
        self.log(f"Exported pickle: {filepath.name}", level="success")
        return filepath
    
    def export_metrics(self, filename: str = "metrics") -> Path:
        """
        Export all tracked metrics to both JSON and CSV.
        
        Args:
            filename: Base filename (without extension)
            
        Returns:
            Path to the JSON file
        """
        if not self._metrics_history:
            self.warning("No metrics to export")
            return self.experiment_dir
        
        json_path = self.export_json(self._metrics_history, f"{filename}.json")
        self.export_csv(self._metrics_history, f"{filename}.csv")
        
        return json_path
    
    # =========================================================================
    # CHART / GRAPH EXPORT METHODS
    # =========================================================================
    
    def export_figure(
        self,
        fig,
        filename: str,
        subfolder: Optional[str] = None,
        dpi: int = 150,
        tight: bool = True,
        close_after: bool = True,
    ) -> Path:
        """
        Export a matplotlib figure to PNG.
        
        Args:
            fig: matplotlib Figure object
            filename: Output filename (with or without .png extension)
            subfolder: Optional subfolder within experiment directory
            dpi: Resolution (dots per inch)
            tight: Whether to use tight_layout
            close_after: Whether to close the figure after saving
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        if not filename.endswith(".png"):
            filename += ".png"
        
        filepath = self._get_filepath(filename, subfolder)
        
        if tight:
            fig.tight_layout()
        
        fig.savefig(filepath, dpi=dpi, bbox_inches='tight', facecolor='white')
        
        if close_after:
            plt.close(fig)
        
        self.log(f"Exported chart: {filepath.name}", level="success")
        return filepath
    
    def plot_line(
        self,
        x: List,
        y: List,
        filename: str,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: Optional[str] = None,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        style: str = "-o",
        color: Optional[str] = None,
        grid: bool = True,
        **kwargs,
    ) -> Path:
        """
        Create and export a line chart.
        
        Args:
            x: X-axis values
            y: Y-axis values
            filename: Output filename
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            subfolder: Subfolder for charts
            figsize: Figure size (width, height)
            style: Line style (e.g., '-o', '--', 'o')
            color: Line color
            grid: Whether to show grid
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(x, y, style, color=color, **kwargs)
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        if grid:
            ax.grid(True, alpha=0.3)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_lines(
        self,
        data: Dict[str, Tuple[List, List]],
        filename: str,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: Optional[str] = None,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        grid: bool = True,
        legend: bool = True,
    ) -> Path:
        """
        Create and export a multi-line chart.
        
        Args:
            data: Dictionary of {label: (x_values, y_values)}
            filename: Output filename
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            subfolder: Subfolder for charts
            figsize: Figure size
            grid: Whether to show grid
            legend: Whether to show legend
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        
        for label, (x, y) in data.items():
            ax.plot(x, y, '-o', label=label, markersize=4)
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        if grid:
            ax.grid(True, alpha=0.3)
        if legend:
            ax.legend()
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_bar(
        self,
        labels: List[str],
        values: List[float],
        filename: str,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: Optional[str] = None,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        color: Optional[str] = None,
        horizontal: bool = False,
    ) -> Path:
        """
        Create and export a bar chart.
        
        Args:
            labels: Category labels
            values: Bar values
            filename: Output filename
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            subfolder: Subfolder for charts
            figsize: Figure size
            color: Bar color
            horizontal: Whether to make horizontal bars
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        
        if horizontal:
            ax.barh(labels, values, color=color or '#4A90D9')
        else:
            ax.bar(labels, values, color=color or '#4A90D9')
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_scatter(
        self,
        x: List,
        y: List,
        filename: str,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: Optional[str] = None,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        color: Optional[str] = None,
        size: int = 50,
        alpha: float = 0.7,
    ) -> Path:
        """
        Create and export a scatter plot.
        
        Args:
            x: X-axis values
            y: Y-axis values
            filename: Output filename
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            subfolder: Subfolder for charts
            figsize: Figure size
            color: Point color
            size: Point size
            alpha: Point transparency
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        ax.scatter(x, y, s=size, c=color or '#E94B3C', alpha=alpha)
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        ax.grid(True, alpha=0.3)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_histogram(
        self,
        data: List[float],
        filename: str,
        bins: int = 30,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: str = "Frequency",
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        color: Optional[str] = None,
    ) -> Path:
        """
        Create and export a histogram.
        
        Args:
            data: Data values
            filename: Output filename
            bins: Number of bins
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            subfolder: Subfolder for charts
            figsize: Figure size
            color: Bar color
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        ax.hist(data, bins=bins, color=color or '#6B5B95', edgecolor='white', alpha=0.8)
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_heatmap(
        self,
        data: List[List[float]],
        filename: str,
        title: Optional[str] = None,
        xlabel: Optional[str] = None,
        ylabel: Optional[str] = None,
        xlabels: Optional[List[str]] = None,
        ylabels: Optional[List[str]] = None,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 8),
        cmap: str = "viridis",
        annotate: bool = True,
    ) -> Path:
        """
        Create and export a heatmap.
        
        Args:
            data: 2D array of values
            filename: Output filename
            title: Chart title
            xlabel: X-axis label
            ylabel: Y-axis label
            xlabels: Labels for x-axis ticks
            ylabels: Labels for y-axis ticks
            subfolder: Subfolder for charts
            figsize: Figure size
            cmap: Colormap name
            annotate: Whether to show values in cells
            
        Returns:
            Path to the created file
        """
        plt = _get_plt()
        import numpy as np
        
        fig, ax = plt.subplots(figsize=figsize)
        
        data_array = np.array(data)
        im = ax.imshow(data_array, cmap=cmap, aspect='auto')
        
        # Add colorbar
        plt.colorbar(im, ax=ax)
        
        # Set ticks
        if xlabels:
            ax.set_xticks(range(len(xlabels)))
            ax.set_xticklabels(xlabels, rotation=45, ha='right')
        if ylabels:
            ax.set_yticks(range(len(ylabels)))
            ax.set_yticklabels(ylabels)
        
        # Annotate cells
        if annotate and data_array.size <= 100:  # Only annotate small heatmaps
            for i in range(data_array.shape[0]):
                for j in range(data_array.shape[1]):
                    val = data_array[i, j]
                    color = 'white' if val > data_array.mean() else 'black'
                    ax.text(j, i, f'{val:.2f}', ha='center', va='center', color=color, fontsize=8)
        
        if title:
            ax.set_title(title, fontsize=14, fontweight='bold')
        if xlabel:
            ax.set_xlabel(xlabel)
        if ylabel:
            ax.set_ylabel(ylabel)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_metrics(
        self,
        metric_names: Optional[List[str]] = None,
        filename: str = "metrics_plot",
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (12, 6),
    ) -> Optional[Path]:
        """
        Plot tracked metrics history.
        
        Args:
            metric_names: List of metric names to plot (None = all)
            filename: Output filename
            subfolder: Subfolder for charts
            figsize: Figure size
            
        Returns:
            Path to the created file, or None if no metrics
        """
        if not self._metrics_history:
            self.warning("No metrics to plot")
            return None
        
        plt = _get_plt()
        
        # Get all metric names (excluding step and timestamp)
        all_metrics = set()
        for entry in self._metrics_history:
            all_metrics.update(k for k in entry.keys() if k not in ('step', 'timestamp'))
        
        if metric_names:
            metrics_to_plot = [m for m in metric_names if m in all_metrics]
        else:
            metrics_to_plot = list(all_metrics)
        
        if not metrics_to_plot:
            self.warning("No valid metrics found to plot")
            return None
        
        # Create subplots
        n_metrics = len(metrics_to_plot)
        cols = min(2, n_metrics)
        rows = (n_metrics + cols - 1) // cols
        
        fig, axes = plt.subplots(rows, cols, figsize=(figsize[0], figsize[1] * rows / 2))
        if n_metrics == 1:
            axes = [axes]
        else:
            axes = axes.flatten() if hasattr(axes, 'flatten') else [axes]
        
        for idx, metric_name in enumerate(metrics_to_plot):
            ax = axes[idx]
            
            # Extract data for this metric
            steps = []
            values = []
            for entry in self._metrics_history:
                if metric_name in entry:
                    steps.append(entry['step'])
                    values.append(entry[metric_name])
            
            ax.plot(steps, values, '-o', markersize=4)
            ax.set_title(metric_name, fontsize=12, fontweight='bold')
            ax.set_xlabel('Step')
            ax.grid(True, alpha=0.3)
        
        # Hide unused subplots
        for idx in range(n_metrics, len(axes)):
            axes[idx].set_visible(False)
        
        fig.suptitle('Metrics Over Time', fontsize=14, fontweight='bold', y=1.02)
        
        return self.export_figure(fig, filename, subfolder)
    
    def plot_custom(
        self,
        plot_fn: Callable,
        filename: str,
        subfolder: str = "charts",
        figsize: Tuple[int, int] = (10, 6),
        **kwargs,
    ) -> Path:
        """
        Create a custom plot using a callback function.
        
        Args:
            plot_fn: Function that takes (fig, ax) and creates the plot
            filename: Output filename
            subfolder: Subfolder for charts
            figsize: Figure size
            **kwargs: Additional arguments passed to plot_fn
            
        Returns:
            Path to the created file
            
        Example:
            def my_plot(fig, ax):
                ax.plot([1, 2, 3], [1, 4, 9])
                ax.set_title("Custom Plot")
            
            logger.plot_custom(my_plot, "custom_chart")
        """
        plt = _get_plt()
        
        fig, ax = plt.subplots(figsize=figsize)
        plot_fn(fig, ax, **kwargs)
        
        return self.export_figure(fig, filename, subfolder)
    
    # =========================================================================
    # DATA IMPORT METHODS
    # =========================================================================
    
    def load_json(self, filename: str, subfolder: Optional[str] = None) -> Any:
        """Load data from a JSON file."""
        if not filename.endswith(".json"):
            filename += ".json"
        
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "r") as f:
            return json.load(f)
    
    def load_pickle(self, filename: str, subfolder: Optional[str] = None) -> Any:
        """Load data from a pickle file."""
        if not filename.endswith(".pkl"):
            filename += ".pkl"
        
        filepath = self._get_filepath(filename, subfolder)
        
        with open(filepath, "rb") as f:
            return pickle.load(f)
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def _get_filepath(self, filename: str, subfolder: Optional[str] = None) -> Path:
        """Get the full filepath, creating subdirectories if needed."""
        if subfolder:
            directory = self.experiment_dir / subfolder
            directory.mkdir(parents=True, exist_ok=True)
        else:
            directory = self.experiment_dir
        
        return directory / filename
    
    def create_subfolder(self, name: str) -> Path:
        """Create a subfolder within the experiment directory."""
        subfolder = self.experiment_dir / name
        subfolder.mkdir(parents=True, exist_ok=True)
        return subfolder
    
    def get_path(self, filename: Optional[str] = None) -> Path:
        """Get path to experiment directory or a specific file within it."""
        if filename:
            return self.experiment_dir / filename
        return self.experiment_dir
    
    @contextmanager
    def timer(self, task_name: str):
        """
        Context manager for timing code blocks.
        
        Usage:
            with logger.timer("training"):
                train_model()
        """
        self.log(f"Starting: {task_name}", level="info")
        start = time.perf_counter()
        try:
            yield
        finally:
            elapsed = time.perf_counter() - start
            self.log(f"Completed: {task_name} ({elapsed:.2f}s)", level="success")
    
    def timed(self, func):
        """
        Decorator for timing function calls.
        
        Usage:
            @logger.timed
            def my_function():
                ...
        """
        @wraps(func)
        def wrapper(*args, **kwargs):
            with self.timer(func.__name__):
                return func(*args, **kwargs)
        return wrapper
    
    def summarize(self) -> Dict[str, Any]:
        """
        Generate and log a summary of the experiment.
        
        Returns:
            Dictionary with experiment summary
        """
        elapsed = datetime.now() - self.start_time
        
        summary = {
            "experiment_name": self.experiment_name,
            "start_time": self.start_time.isoformat(),
            "duration_seconds": elapsed.total_seconds(),
            "duration_human": str(elapsed).split(".")[0],
            "total_steps": self._step,
            "metrics_logged": len(self._metrics_history),
            "log_directory": str(self.experiment_dir),
        }
        
        self.separator()
        self.header("EXPERIMENT SUMMARY")
        for key, value in summary.items():
            self.log(f"{key}: {value}", level="info")
        self.separator()
        
        # Export summary
        self.export_json(summary, "summary.json")
        
        return summary


# =============================================================================
# QUICK ACCESS FUNCTIONS
# =============================================================================

def quick_log(message: str, level: str = "info") -> None:
    """Quick one-off logging without creating an ExperimentLogger instance."""
    now = datetime.now().strftime("%H:%M:%S")
    color = LEVEL_COLORS.get(level, "")
    icon = LEVEL_ICONS.get(level, "")
    print(f"{Colors.DIM}{now}{Colors.RESET} {color}[{level.upper():^8}]{Colors.RESET} {icon} {message}")


def quick_export_json(data: Any, filename: str, directory: Optional[str] = None) -> Path:
    """Quick JSON export without creating an ExperimentLogger instance."""
    logs_root = Path(__file__).parent.parent.parent / "logs"
    
    if directory:
        path = logs_root / directory
    else:
        path = logs_root
    
    path.mkdir(parents=True, exist_ok=True)
    
    if not filename.endswith(".json"):
        filename += ".json"
    
    filepath = path / filename
    with open(filepath, "w") as f:
        json.dump(data, f, indent=2, default=str)
    
    quick_log(f"Exported: {filepath}", level="success")
    return filepath


# =============================================================================
# USAGE EXAMPLE (when run directly)
# =============================================================================

if __name__ == "__main__":
    import random
    
    # Demo the logger
    logger = ExperimentLogger("demo_experiment")
    
    logger.header("Demo Experiment Run")
    
    # Log various levels
    logger.debug("This is a debug message")
    logger.info("This is an info message")
    logger.success("This is a success message")
    logger.warning("This is a warning message")
    logger.error("This is an error message")
    
    logger.separator()
    
    # Track some metrics
    for epoch in range(10):
        logger.log_metrics({
            "loss": 1.0 / (epoch + 1) + random.uniform(0, 0.1),
            "accuracy": 0.5 + epoch * 0.05 + random.uniform(-0.02, 0.02),
        }, prefix="train")
    
    # Export some data
    config = {
        "model": "transformer",
        "layers": 6,
        "hidden_dim": 512,
        "learning_rate": 0.001,
    }
    logger.export_json(config, "config")
    
    # Export metrics
    logger.export_metrics()
    
    # ============= CHART DEMOS =============
    logger.header("Chart Export Demo")
    
    # Try to generate charts (requires matplotlib)
    try:
        # Line chart
        x = list(range(1, 11))
        y = [i**2 for i in x]
        logger.plot_line(x, y, "quadratic_growth", 
                        title="Quadratic Growth", 
                        xlabel="Step", 
                        ylabel="Value")
        
        # Multi-line chart
        logger.plot_lines({
            "train_loss": (x, [1.0/i for i in x]),
            "val_loss": (x, [1.2/i + 0.05 for i in x]),
        }, "loss_comparison", title="Loss Comparison", xlabel="Epoch", ylabel="Loss")
        
        # Bar chart
        logger.plot_bar(
            ["Model A", "Model B", "Model C", "Model D"],
            [0.85, 0.92, 0.78, 0.88],
            "model_comparison",
            title="Model Accuracy Comparison",
            ylabel="Accuracy"
        )
        
        # Scatter plot
        scatter_x = [random.gauss(0, 1) for _ in range(50)]
        scatter_y = [x + random.gauss(0, 0.5) for x in scatter_x]
        logger.plot_scatter(scatter_x, scatter_y, "correlation_plot",
                           title="Feature Correlation",
                           xlabel="Feature X",
                           ylabel="Feature Y")
        
        # Histogram
        hist_data = [random.gauss(0, 1) for _ in range(500)]
        logger.plot_histogram(hist_data, "weight_distribution",
                             title="Weight Distribution",
                             xlabel="Weight Value")
        
        # Heatmap
        heatmap_data = [[random.random() for _ in range(5)] for _ in range(5)]
        logger.plot_heatmap(heatmap_data, "attention_weights",
                          title="Attention Weights",
                          xlabels=["Q1", "Q2", "Q3", "Q4", "Q5"],
                          ylabels=["K1", "K2", "K3", "K4", "K5"])
        
        # Plot all tracked metrics
        logger.plot_metrics()
        
        logger.success("All charts exported to charts/ subfolder!")
        
    except ImportError as e:
        logger.warning(f"Chart export skipped: {e}")
        logger.info("Install matplotlib for chart support: pip install matplotlib")
    
    # Timer demo
    with logger.timer("simulated_training"):
        time.sleep(0.5)
    
    # Summarize
    logger.summarize()
    
    print(f"\nüìÅ Check out: {logger.experiment_dir}")

